/*******************************
 ***** SECTION 1 - OPTIONS *****
 *******************************/

options {
  JAVA_UNICODE_ESCAPE = true;
}

/*********************************
 ***** SECTION 2 - USER CODE *****
 *********************************/

PARSER_BEGIN(CCALParser)

public class CCALParser {

    public static void main(String args[]) {

        CCALParser parser;

        if (args.length == 0) {

            System.out.println("CCAL Parser:  Reading from standard input . . .");
            parser = new CCALParser(System.in);

        } else if (args.length == 1) {

            System.out.println("CCAL Parser:  Reading from file " + args[0] + " . . .");

            try {

                parser = new CCALParser(new java.io.FileInputStream(args[0]));

            } catch (java.io.FileNotFoundException e) {

                System.out.println("CCAL Parser:  File " + args[0] + " not found.");
                return;
            }

        } else {

            System.out.println("CCAL Parser:  Usage is one of:");
            System.out.println("         java CCALParser < inputfile");
            System.out.println("OR");
            System.out.println("         java CCALParser inputfile");
            return;

        } try {

            parser.Prog();
            System.out.println("CCAL Parser: CCAL program parsed successfully.");

        } catch (ParseException e) {

            System.out.println(e.getMessage());
            System.out.println("CCAL Parser:  Encountered errors during parse.");
        }
    }
}

PARSER_END(CCALParser)

/*****************************************
 ***** SECTION 3 - TOKEN DEFINITIONS *****
 *****************************************/

TOKEN_MGR_DECLS : {

    static int commentNesting=0;
}

SKIP : /*** Ignoring spaces/tabs/newlines ***/ {

      " "
    | "\t"
    | "\n"
    | "\r"
    | "\f"
}

SKIP : /* COMMENTS */ {

    "/*" { commentNesting++; } : IN_COMMENT
}

<IN_COMMENT> SKIP : {

      "/*" { commentNesting++; }
    | "*/" {
        commentNesting--;
        if (commentNesting == 0) {
            SwitchTo(DEFAULT);
        }
    }
    | <~[]>
}

TOKEN :  /* Keywords and punctuation */ {

      < SEMIC : ";" >
    | < COLON : ":" >
    | < ASSIGN : "=" >
    | < RETURN : "return" >
    | < LBR : "(" >
    | < RBR : ")" >
    | < LCB : "{" >
    | < RCB : "}" >
    | < COMMA : "," >
    | < PLUS_SIGN : "+" >
    | < MINUS_SIGN : "-" >
    | < AND : "&&" >
    | < OR : "||" >
    | < NEGATE : "~" >
    | < EQUAL : "==" >
    | < NOT_EQ : "!=" >
    | < GT : ">" >
    | < GTEQ : ">=" >
    | < LT : "<" >
    | < LTEQ : "<=" >
    | < INTEGER : "int" >
    | < BOOLEAN : "bool" >
    | < VOID : "void" >
}

TOKEN :  /* Numbers and identifiers */ {

      < NUM : (<DIGIT>)+ >
    | < #DIGIT : ["0" - "9"] >
    | < ID : (<LETTER>)+ >
    | < #LETTER : ["a" - "z", "A" - "Z"] >
}


TOKEN : /* Anything not recognised so far */ {
    < OTHER : ~[] >
}

/***************************
 * SECTION 4 - THE GRAMMAR *
 ***************************/

void Program() : {} {

    DeclarationList() FunctionList() Main()
}

void DeclarationList() : {} {

    (Declaration() <SEMIC> DeclarationList())
    | {}
}

void Declaration() : {} {

    VariableDeclaration()
    | {}
}

void VariableDeclaration() : {} {

    <VAR> <ID> <SEMIC> Type()
}

void ConstantDeclaration() : {} {

    <CONST> <ID> <SEMIC> Type() <ASSIGN> Expression()
}

void FunctionList() : {} {

    (Function() FunctionList())
    | {}
}

void Function() : {} {

    Type() <ID> <LBR> ParameterList() <RBR>
    <LCB>
    DeclarationList()
    StatementBlock()
    <RETURN> <LBR> (Expression() | {}) <RBR> <SEMIC>
    <RCB>
}

void Type() : {} {

    <INTEGER> | <BOOLEAN> | <VOID>
}

void 

/////////////////
void Stm() : {} {

    (SimpleStm() [<SEMIC> Stm()] )
}

void SimpleStm() : {} {

      (Ident() <ASSIGN> Exp())
    | (<PRINT> <LBR> ExpList() <RBR>)
}

void Exp() : {} {

    (SimpleExp() [BinOp() Exp()]  )
}

void SimpleExp() : {} {

      IdExp()
    | NumExp()
    | (<LBR> Stm() <COMMA> Exp() <RBR>)
}

void Ident() : {} {

    <ID>
}

void IdExp() : {} {

    <ID>
}

void NumExp() : {} {

    <NUM>
}

void ExpList() : {} {

    (Exp() [<COMMA> ExpList()] )
}


void BinOp() : {} {

      <PLUS_SIGN>
    | <MINUS_SIGN>
    | <MULT_SIGN>
    | <DIV_SIGN>
}

//
// void Prog() : {} {
//
//     Stm() <EOF>
// }
//
// void Stm() : {} {
//
//     (SimpleStm() [<SEMIC> Stm()] )
// }
//
// void SimpleStm() : {} {
//
//       (Ident() <ASSIGN> Exp())
//     | (<PRINT> <LBR> ExpList() <RBR>)
// }
//
// void Exp() : {} {
//
//     (SimpleExp() [BinOp() Exp()]  )
// }
//
// void SimpleExp() : {} {
//
//       IdExp()
//     | NumExp()
//     | (<LBR> Stm() <COMMA> Exp() <RBR>)
// }
//
// void Ident() : {} {
//
//     <ID>
// }
//
// void IdExp() : {} {
//
//     <ID>
// }
//
// void NumExp() : {} {
//
//     <NUM>
// }
//
// void ExpList() : {} {
//
//     (Exp() [<COMMA> ExpList()] )
// }
//
//
// void BinOp() : {} {
//
//       <PLUS_SIGN>
//     | <MINUS_SIGN>
//     | <MULT_SIGN>
//     | <DIV_SIGN>
// }
