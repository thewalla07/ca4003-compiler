/*******************************
 ***** SECTION 1 - OPTIONS *****
 *******************************/

options {
  JAVA_UNICODE_ESCAPE = true;
}

/*********************************
 ***** SECTION 2 - USER CODE *****
 *********************************/

PARSER_BEGIN(CCALParser)

public class CCALParser {

    public static void main(String args[]) {

        CCALParser parser;

        if (args.length == 0) {

            System.out.println("CCAL Parser:  Reading from standard input . . .");
            parser = new CCALParser(System.in);

        } else if (args.length == 1) {

            System.out.println("CCAL Parser:  Reading from file " + args[0] + " . . .");

            try {

                parser = new CCALParser(new java.io.FileInputStream(args[0]));

            } catch (java.io.FileNotFoundException e) {

                System.out.println("CCAL Parser:  File " + args[0] + " not found.");
                return;
            }

        } else {

            System.out.println("CCAL Parser:  Usage is one of:");
            System.out.println("         java CCALParser < inputfile");
            System.out.println("OR");
            System.out.println("         java CCALParser inputfile");
            return;

        } try {

            parser.Prog();
            System.out.println("CCAL Parser: CCAL program parsed successfully.");

        } catch (ParseException e) {

            System.out.println(e.getMessage());
            System.out.println("CCAL Parser:  Encountered errors during parse.");
        }
    }
}

PARSER_END(CCALParser)

/*****************************************
 ***** SECTION 3 - TOKEN DEFINITIONS *****
 *****************************************/

TOKEN_MGR_DECLS : {

    static int commentNesting=0;
}

SKIP : /*** Ignoring spaces/tabs/newlines ***/ {

      " "
    | "\t"
    | "\n"
    | "\r"
    | "\f"
}

SKIP : /* COMMENTS */ {

    "/*" { commentNesting++; } : IN_COMMENT
    | < "//" ( ~["\r", "\n" ] )* >
}

<IN_COMMENT> SKIP : {

      "/*" { commentNesting++; }
    | "*/" {
        commentNesting--;
        if (commentNesting == 0) {
            SwitchTo(DEFAULT);
        }
    }
    | <~[]>
}

TOKEN :  /* Keywords and punctuation */ {

      < SEMIC : ";" >
    | < COLON : ":" >
    | < ASSIGN : "=" >
    | < RETURN : "return" >
    | < MAIN : "main" >
    | < LBR : "(" >
    | < RBR : ")" >
    | < LCB : "{" >
    | < RCB : "}" >
    | < COMMA : "," >
    | < PLUS_SIGN : "+" >
    | < MINUS_SIGN : "-" >
    | < AND : "&&" >
    | < OR : "||" >
    | < NEGATE : "~" >
    | < EQUAL : "==" >
    | < NOT_EQ : "!=" >
    | < GT : ">" >
    | < GTEQ : ">=" >
    | < LT : "<" >
    | < LTEQ : "<=" >
    | < INTEGER : "integer" >
    | < BOOLEAN : "boolean" >
    | < VOID : "void" >
    | < VAR : "var" >
    | < CONST : "const" >
    | < IF : "if" >
    | < WHILE : "while" >
    | < SKIPPER : "skip" >
    | < ELSE : "else" >
    | < TRUE : "true" >
    | < FALSE : "false" >
}

TOKEN :  /* Numbers and identifiers */ {

      < NUM : (<DIGIT>)+ >
    | < #DIGIT : ["0" - "9"] >
    | < ID : (<LETTER>)+ >
    | < #LETTER : ["a" - "z", "A" - "Z"] >
}


TOKEN : /* Anything not recognised so far */ {
    < OTHER : ~[] >
}

/***************************
 * SECTION 4 - THE GRAMMAR *
 ***************************/

void Program() : {} {

    DeclarationList() FunctionList() Main()
}

void DeclarationList() : {} {

    (Declaration() <SEMIC> DeclarationList())
    | {}
}

void Declaration() : {} {

    VariableDeclaration()
    | {}
}

void VariableDeclaration() : {} {

    <VAR> <ID> <SEMIC> Type()
}

void ConstantDeclaration() : {} {

    <CONST> <ID> <SEMIC> Type() <ASSIGN> Expression()
}

void FunctionList() : {} {

    (Function() FunctionList())
    | {}
}

void Function() : {} {

    Type() <ID> <LBR> ParameterList() <RBR>
    <LCB>
    DeclarationList()
    StatementBlock()
    <RETURN> <LBR> (Expression() | {}) <RBR> <SEMIC>
    <RCB>
}

void Type() : {} {

    <INTEGER> | <BOOLEAN> | <VOID>
}

void ParameterList() : {} {

    NempParameterList()
    | {}
}

void NempParameterList() : {} {

    <ID> <COLON> Type() (
        <COMMA> NempParameterList()
        | {}
    )
}

void Main() : {} {

    <MAIN> <LCB>
    DeclarationList()
    StatementBlock()
    <RCB>
}

void StatementBlock() : {} {

    (Statement() StatementBlock())
    | {}
}

void Statement() : {} {

    <ID> (
        <ASSIGN> Expression() <SEMIC>
        | <LBR> ArgumentList() <RBR> <SEMIC>
    )
    | <LCB> StatementBlock() <RCB>
    | <IF> Condition() <LCB> StatementBlock() <RCB> <ELSE> <LCB> StatementBlock() <RCB>
    | <WHILE> Condition() <LCB> StatementBlock() <RCB>
    | <SKIPPER> <SEMIC>
}

void Expression() : {} {

    Fragment() (
        (BinaryArithmeticOperation() Fragment())
        | {}
    )
    | ExpressionPrime()
}

void FragExprPrime() : {} {

    <ID> (
        <LBR> ArgumentList() <RBR>
        | ExpressionPrime()
    )
}

void Fragment() : {} {

    <MINUS_SIGN> <ID>
    | <NUM>
    | <TRUE>
    | <FALSE>
    | ExpressionPrime()
}

void ExpressionPrime() : {} {

    <LBR> (
        ExpressionPrime() <RBR>
        | ArgumentList() <RBR>
    )
}

// reference for removing left recursion:
// http://www.cs.may.ie/staff/jpower/Courses/Previous/parsing/node30.html

void BinaryArithmeticOperation() : {} {

    <PLUS_SIGN>
    | <MINUS_SIGN>
}

// Fragment

// void Condition() : {} {
//
//     <NEGATE> Condition()
//     | <LBR> Condition() <RBR>
//     | Expression() ComparisonOperator() Expression()
//     | Condition() ( <OR> | <AND> ) Condition()
// }

// left recursion removal followed from notes in lectures

void Condition() : {} {

    Expression() ComparisonOperator() Expression() ConditionPrime()
}

void ConditionPrime() : {} {

    <NEGATE> ConditionPrime()
    | <LBR> ConditionPrime() <RBR>
    | (<OR> | <AND>) ConditionPrime()
    | {}
}

void ComparisonOperator() : {} {

    <EQUAL>
    | <NOT_EQ>
    | <LT>
    | <LTEQ>
    | <GT>
    | <GTEQ>
}

void ArgumentList() : {} {

    NempArgumentList()
    | {}
}

void NempArgumentList() : {} {

    <ID>
    | <ID> <COMMA> NempArgumentList()
}

/////////////////

//
// void Prog() : {} {
//
//     Stm() <EOF>
// }
//
// void Stm() : {} {
//
//     (SimpleStm() [<SEMIC> Stm()] )
// }
//
// void SimpleStm() : {} {
//
//       (Ident() <ASSIGN> Exp())
//     | (<PRINT> <LBR> ExpList() <RBR>)
// }
//
// void Exp() : {} {
//
//     (SimpleExp() [BinOp() Exp()]  )
// }
//
// void SimpleExp() : {} {
//
//       IdExp()
//     | NumExp()
//     | (<LBR> Stm() <COMMA> Exp() <RBR>)
// }
//
// void Ident() : {} {
//
//     <ID>
// }
//
// void IdExp() : {} {
//
//     <ID>
// }
//
// void NumExp() : {} {
//
//     <NUM>
// }
//
// void ExpList() : {} {
//
//     (Exp() [<COMMA> ExpList()] )
// }
//
//
// void BinOp() : {} {
//
//       <PLUS_SIGN>
//     | <MINUS_SIGN>
//     | <MULT_SIGN>
//     | <DIV_SIGN>
// }
